# JVM
## java内存模型与java内存结构
- 内存模型（JMM）：描述的是多线程允许的行为，主内存 -- 工作内存 -- java线程
- 内存结构（JVM）：描述的是线程运行所设计的内存空间。类加载器 -- 运行时数据区 -- 执行引擎

[JMM && JVM](https://www.cnblogs.com/chuonye/p/11349042.html)

==JRE：java运行时的环境 JRE=虚拟机平台+虚拟机本体(JVM) -- 电脑 + JVM==

## 生产环境中的JVM需要的默认的配置
- 堆内存
    - -Xms : 堆的最小值 2048
    - -Xmx : 堆的最大值
    - 一般都设置成一样的
- 元空间的阈值：触发full GC `-XX:MetaspaceSize`：默认是21M
- 元空间的最大值：`-XX:MaxMetaspaceSize`，默认是-1，没有大小的限制，与本地内存有关
- 设置垃圾回收器：
    - java8中默认的垃圾回收器：parallel GC，parallel old GC
    - `-XX:+UseConcMarkSweepGC`：老年代的垃圾回收器：CMS（**使用标记-清除算法**），使用Serial old GC（**标记压缩算法**）作为备选的垃圾回收器       
        - 初始标记
        - 并发标记
        - 重新标记
        - 并发回收
        - 线程整理
    - `-XX:+UseParNewGC`：年轻代使用的垃圾回收器，在serial GC的基础上改进（**复制算法**）
    - `-verbose:gc`：显示gc的信息
    - `-XX:+PrintGCDetails`：打印GC的详细的信息
    - `-Xloggc:/home/admin/logs/gc.log`：垃圾回收的日志保存的地址
    - `+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs`：当堆内存空间溢出时输出堆的内存快照到指定的 /home/admin/logs


## 及时编译器（JIT）
当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行

#### 热点代码有哪些
- 多次调用的方法
- 被多次执行的循环体

#### 怎么去判断是否是热点代码
- 基于采样的热点检测：循环的去检测，各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”。实现简单高效，**但是很难精确确认一个方法的热度**（一般不会使用）
- 使用计数器（常使用该方法）：
    - 方法调用计数器
    - 回边计数器（判断循环体）

![方法调用计数器](./media/16121006208269/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.png)
![回边计数器](./media/16121006208269/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.png)

## 解释器与编译器
解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。此外，如果编译后出现“罕见陷阱”，可以通过逆优化退回到解释执行。

![解释器与编译器的交互](./media/16121006208269/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92.png)

## Java虚拟机调用字节码指令有哪些?
- invokestatic:调用静态方法
- invokespecial:调用实例构造器方法、私有方法和父类方法
- invokevirtual:调用所有的虚方法
- invokeinterface:调用接口方法

## 对象
- 对象头
- 实例数据
- 对齐填充：
    - 8字节的倍数

## 双亲委派机制的好处：
- 防止类的重复加载
- 保护java源代码的安全，不被篡改使用

#### 怎么去判断两个类是不是相等的：
- 全限类名是否相等
- 使用的类加载器是否相等

## 其他
加载 -- 链接（验证，准备，解析） -- 初始化

static不能直接调用一般的属性

static不能直接的调用this
this不存在与static方法的局部变量表中

在java8中，方法区中包含类型信息，域信息，方法信息，JIT代码缓存，**运行时常量池**

静态变量，字符串常量池保存在堆中

**为什么要把字符串常量池放在堆中**
在方法区中，回收的效率是比较低的，但是JDK8中，将字符串常量池放在了堆中，方便尽心回收

一个对象的finalize只会被调用一次，（可触及对象，可复活对象，不可触及对象）
- 复述finalize的过程

对象在被回收前都会执行finalize


CMS : 
- 初始标记（标记直接的与GCRoots关联的对象）STW
- 并发标记
- 重新标记（STW）
- 并发清除